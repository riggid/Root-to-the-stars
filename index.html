<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Space Trajectory Planner</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<style>
  body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background: #0b0b0f; }
  canvas { display: block; }
  .planet-label {
    color: white;
    font-size: 12px;
    text-shadow: 0 0 4px black;
  }
</style>
</head>
<body>
<div id="container" class="relative w-full h-screen">
  <canvas id="spaceCanvas"></canvas>

  <div class="absolute top-4 left-4 p-4 rounded-lg bg-black bg-opacity-70 max-w-sm space-y-2">
    <h1 class="text-2xl font-bold text-white mb-2">Trajectory Planner</h1>

    <label class="text-white font-medium">Origin Planet:</label>
    <select id="origin" class="w-full mb-2 rounded border border-gray-600 bg-black text-white p-1">
      <option>Earth</option>
      <option>Mars</option>
      <option>Venus</option>
      <option>Mercury</option>
      <option>Jupiter</option>
      <option>Saturn</option>
      <option>Uranus</option>
      <option>Neptune</option>
    </select>

    <label class="text-white font-medium">Target Planet:</label>
    <select id="target" class="w-full mb-2 rounded border border-gray-600 bg-black text-white p-1">
      <option>Mars</option>
      <option>Earth</option>
      <option>Venus</option>
      <option>Mercury</option>
      <option>Jupiter</option>
      <option>Saturn</option>
      <option>Uranus</option>
      <option>Neptune</option>
    </select>

    <label class="text-white font-medium">Departure Earliest:</label>
    <input type="date" id="dep_start" class="w-full mb-2 rounded p-1 bg-black border border-gray-600 text-white" value="2025-09-20">

    <label class="text-white font-medium">TOF (days):</label>
    <div class="flex space-x-2 mb-2">
      <input type="number" id="tof_min" class="w-1/2 rounded p-1 bg-black border border-gray-600 text-white" value="120">
      <input type="number" id="tof_max" class="w-1/2 rounded p-1 bg-black border border-gray-600 text-white" value="400">
    </div>

    <label class="text-white font-medium">View Planets At:</label>
    <input type="date" id="viewDate" class="w-full mb-2 rounded p-1 bg-black border border-gray-600 text-white" value="2025-09-13">

    <button id="computeBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white p-2 rounded font-semibold">Compute Trajectory</button>
    <button id="refreshPositions" class="w-full bg-green-600 hover:bg-green-700 text-white p-2 rounded font-semibold mb-2">Refresh Planet Positions</button>
    <p id="status" class="text-yellow-400 text-sm mt-1">Select planets and press Compute.</p>
    <p id="positionStatus" class="text-green-400 text-xs">Loading live planet positions...</p>
    
    <div id="results" class="mt-4 hidden">
      <h3 class="text-lg font-bold text-white mb-2">Trajectory Details</h3>
      <div class="bg-gray-800 p-3 rounded-lg text-sm">
        <p id="resultOrigin" class="text-white"></p>
        <p id="resultTarget" class="text-white"></p>
        <p id="resultDeparture" class="text-white"></p>
        <p id="resultTOF" class="text-white"></p>
        <p id="resultDeltaV" class="text-white"></p>
      </div>
    </div>
  </div>
</div>

<script>
let scene, camera, renderer;

scene = new THREE.Scene();
camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
renderer = new THREE.WebGLRenderer({ antialias:true, canvas: document.getElementById('spaceCanvas') });
renderer.setSize(window.innerWidth, window.innerHeight);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.minDistance = 1;
controls.maxDistance = 1000;

camera.position.set(20, 8, 20);
camera.lookAt(0, 0, 0);

// --- Stars ---
const starGeo = new THREE.BufferGeometry();
const starVertices = [];
for(let i=0;i<10000;i++){
  starVertices.push((Math.random()-0.5)*6000, (Math.random()-0.5)*6000, (Math.random()-0.5)*6000);
}
starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starVertices,3));
const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color:0xffffff, size:1.2 }));
scene.add(stars);

// --- Sun ---
const sun = new THREE.Mesh(new THREE.SphereGeometry(5,32,32), new THREE.MeshBasicMaterial({ color:0xffdd33 }));
scene.add(sun);

// --- Planets ---
const AU = 149597870; // km
const planetData = [
  {name:'Mercury', radius:2.44, orbit:0.387*AU, color:0x909090},
  {name:'Venus', radius:6.05, orbit:0.723*AU, color:0xe6c27a},
  {name:'Earth', radius:6.37, orbit:1*AU, color:0x3a90ff},
  {name:'Mars', radius:3.39, orbit:1.524*AU, color:0xff4500},
  {name:'Jupiter', radius:69.91, orbit:5.203*AU, color:0xd4a06a},
  {name:'Saturn', radius:58.23, orbit:9.537*AU, color:0xf1d17b},
  {name:'Uranus', radius:25.36, orbit:19.191*AU, color:0x7fe6ff},
  {name:'Neptune', radius:24.62, orbit:30.07*AU, color:0x2e70c1},
];

const planetMeshes = {};
const scaleFactor = 0.00001;

planetData.forEach(p=>{
  const planetSize = Math.max(p.radius * 5, 2);
  const mesh = new THREE.Mesh(new THREE.SphereGeometry(planetSize,32,32),
    new THREE.MeshStandardMaterial({color:p.color}));
  scene.add(mesh);
  planetMeshes[p.name] = mesh;
});

scene.add(new THREE.AmbientLight(0x404040,1.0));
scene.add(new THREE.PointLight(0xffffff,2));

// --- Live Planet Positions ---
let planetPositions = {};

async function updatePlanetPositions(date=null) {
  const statusEl = document.getElementById('positionStatus');
  try {
    statusEl.textContent = 'Updating planet positions...';
    let url = 'http://127.0.0.1:8000/api/planet-positions';
    if (date) url += `?date=${date}`;
    const response = await fetch(url);
    planetPositions = await response.json();
    statusEl.textContent = `Loaded positions (${Object.keys(planetPositions).length} planets)`;
  } catch (error) {
    console.error('Failed to fetch planet positions:', error);
    statusEl.textContent = 'Failed to load planet positions';
  }
}
updatePlanetPositions();

// Animate planets
function animate(){
  requestAnimationFrame(animate);
  controls.update();

  planetData.forEach(p=>{
    const mesh = planetMeshes[p.name];
    if (planetPositions[p.name] !== undefined) {
      const longitude = planetPositions[p.name] * Math.PI / 180;
      const x = Math.cos(longitude) * p.orbit * scaleFactor;
      const z = Math.sin(longitude) * p.orbit * scaleFactor;
      mesh.position.set(x, 0, z);
    }
  });

  renderer.render(scene,camera);
}
animate();

// --- Refresh Planet Positions Button ---
document.getElementById("refreshPositions").addEventListener("click", async ()=>{
  const date = document.getElementById("viewDate").value;
  await updatePlanetPositions(date);
});

// --- Trajectory Plotting ---
let trajectoryLine = null;

document.getElementById("computeBtn").addEventListener("click", async ()=>{
  const origin = document.getElementById("origin").value;
  const target = document.getElementById("target").value;
  const dep_start = document.getElementById("dep_start").value;
  const tof_min = parseFloat(document.getElementById("tof_min").value);
  const tof_max = parseFloat(document.getElementById("tof_max").value);
  const statusEl = document.getElementById("status");

  statusEl.textContent = "Computing best trajectory...";
  try{
    const bestRes = await fetch("http://127.0.0.1:8000/best_transfer",{
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ origin, target, dep_start, tof_min, tof_max })
    }).then(r=>r.json());

    const trajRes = await fetch("http://127.0.0.1:8000/trajectory",{
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ origin, target, dep_date:bestRes.dep_date, tof_days:bestRes.tof_days })
    }).then(r=>r.json());

    if(trajectoryLine) scene.remove(trajectoryLine);

    const points = trajRes.trajectory_km.map(p => 
      new THREE.Vector3(p[0]*scaleFactor, p[2]*scaleFactor, p[1]*scaleFactor)
    );
    const geom = new THREE.BufferGeometry().setFromPoints(points);
    trajectoryLine = new THREE.Line(geom, new THREE.LineBasicMaterial({color: 0xff0000}));
    scene.add(trajectoryLine);

    statusEl.textContent = `Trajectory computed: Departure ${bestRes.dep_date}, Î”v ${bestRes.dv.toFixed(2)} km/s`;

    // Show details
    document.getElementById('resultOrigin').textContent = `Origin: ${origin}`;
    document.getElementById('resultTarget').textContent = `Target: ${target}`;
    document.getElementById('resultDeparture').textContent = `Departure Date: ${bestRes.dep_date}`;
    document.getElementById('resultTOF').textContent = `Time of Flight: ${bestRes.tof_days.toFixed(1)} days`;
    document.getElementById('resultDeltaV').textContent = `Delta-V Required: ${bestRes.dv.toFixed(2)} km/s`;
    document.getElementById('results').classList.remove('hidden');
  }catch(err){
    console.error(err);
    statusEl.textContent = "Error computing trajectory.";
  }
});
</script>
</body>
</html>
