<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Space Trajectory Planner</title>
<script src="https://cdn.tailwindcss.com"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<style>
  body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background: #0b0b0f; }
  canvas { display: block; }
  .loader {
    border: 5px solid #f3f3f3;
    border-top: 5px solid #3498db;
    border-radius: 50%;
    width: 50px; height: 50px;
    animation: spin 1s linear infinite;
    position: absolute; top: 50%; left: 50%;
    margin-top: -25px; margin-left: -25px;
  }
  @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
  .planet-label {
    color: white;
    font-size: 12px;
    text-shadow: 0 0 4px black;
  }
</style>
</head>
<body>
<div id="container" class="relative w-full h-screen">
  <canvas id="spaceCanvas"></canvas>
  <div id="loader" class="loader"></div>

  <div class="absolute top-4 left-4 p-4 rounded-lg bg-black bg-opacity-70 max-w-sm space-y-2">
    <h1 class="text-2xl font-bold text-white mb-2">Trajectory Planner</h1>

    <label class="text-white font-medium">Origin Planet:</label>
    <select id="origin" class="w-full mb-2 rounded border border-gray-600 bg-black text-white p-1">
      <option>Earth</option>
      <option>Mars</option>
      <option>Venus</option>
      <option>Mercury</option>
      <option>Jupiter</option>
      <option>Saturn</option>
      <option>Uranus</option>
      <option>Neptune</option>
    </select>

    <label class="text-white font-medium">Target Planet:</label>
    <select id="target" class="w-full mb-2 rounded border border-gray-600 bg-black text-white p-1">
      <option>Mars</option>
      <option>Earth</option>
      <option>Venus</option>
      <option>Mercury</option>
      <option>Jupiter</option>
      <option>Saturn</option>
      <option>Uranus</option>
      <option>Neptune</option>
    </select>

    <label class="text-white font-medium">Departure Start:</label>
    <input type="date" id="dep_start" class="w-full mb-2 rounded p-1 bg-black border border-gray-600 text-white" value="2025-09-20">

    <label class="text-white font-medium">Departure End:</label>
    <input type="date" id="dep_end" class="w-full mb-2 rounded p-1 bg-black border border-gray-600 text-white" value="2025-10-20">

    <label class="text-white font-medium">TOF (days):</label>
    <div class="flex space-x-2 mb-2">
      <input type="number" id="tof_min" class="w-1/2 rounded p-1 bg-black border border-gray-600 text-white" value="120">
      <input type="number" id="tof_max" class="w-1/2 rounded p-1 bg-black border border-gray-600 text-white" value="400">
    </div>

    <button id="computeBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white p-2 rounded font-semibold">Compute Trajectory</button>
    <p id="status" class="text-yellow-400 text-sm mt-1">Select planets and press Compute.</p>
  </div>
</div>

<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 5000);
const renderer = new THREE.WebGLRenderer({ antialias:true, canvas: document.getElementById('spaceCanvas') });
renderer.setSize(window.innerWidth, window.innerHeight);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.minDistance = 50;
controls.maxDistance = 3000;

camera.position.set(500, 400, 800);

// --- Stars ---
const starGeo = new THREE.BufferGeometry();
const starVertices = [];
for(let i=0;i<10000;i++){
  starVertices.push((Math.random()-0.5)*6000, (Math.random()-0.5)*6000, (Math.random()-0.5)*6000);
}
starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starVertices,3));
const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color:0xffffff, size:1.2 }));
scene.add(stars);

// --- Sun ---
const sun = new THREE.Mesh(new THREE.SphereGeometry(25,64,64), new THREE.MeshBasicMaterial({ color:0xffdd33 }));
scene.add(sun);

// --- Realistic Planet Scaling ---
const AU = 149597870; // km
const planetData = [
  {name:'Mercury', radius:2.44, orbit:0.387*AU, color:0x909090},
  {name:'Venus', radius:6.05, orbit:0.723*AU, color:0xe6c27a},
  {name:'Earth', radius:6.37, orbit:1*AU, color:0x3a90ff},
  {name:'Mars', radius:3.39, orbit:1.524*AU, color:0xff4500},
  {name:'Jupiter', radius:69.91, orbit:5.203*AU, color:0xd4a06a},
  {name:'Saturn', radius:58.23, orbit:9.537*AU, color:0xf1d17b},
  {name:'Uranus', radius:25.36, orbit:19.191*AU, color:0x7fe6ff},
  {name:'Neptune', radius:24.62, orbit:30.07*AU, color:0x2e70c1},
];

const planetMeshes = {};
const scaleFactor = 0.01; // scale distances for visualization

planetData.forEach(p=>{
  const mesh = new THREE.Mesh(new THREE.SphereGeometry(p.radius*2,32,32),
    new THREE.MeshStandardMaterial({color:p.color}));
  mesh.position.set(p.orbit*scaleFactor,0,0);
  scene.add(mesh);
  planetMeshes[p.name] = mesh;

  // Orbit ring
  const orbit = new THREE.RingGeometry(p.orbit*scaleFactor-0.5, p.orbit*scaleFactor+0.5, 128);
  const orbitMat = new THREE.MeshBasicMaterial({color:0x555555, side:THREE.DoubleSide});
  const orbitMesh = new THREE.Mesh(orbit, orbitMat);
  orbitMesh.rotation.x = Math.PI/2;
  scene.add(orbitMesh);
});

scene.add(new THREE.AmbientLight(0x404040,1.0));
scene.add(new THREE.PointLight(0xffffff,2));

// --- Animate ---
let time = 0;
function animate(){
  requestAnimationFrame(animate);
  controls.update();
  time += 0.001;

  planetData.forEach(p=>{
    const mesh = planetMeshes[p.name];
    const angle = time*0.5/(p.orbit*scaleFactor); // slower for outer planets
    mesh.position.set(Math.cos(angle)*p.orbit*scaleFactor,0,Math.sin(angle)*p.orbit*scaleFactor);
  });

  renderer.render(scene,camera);
}
animate();

// --- Trajectory Line ---
let trajectoryLine = null;

// --- Fetch Backend & Plot Trajectory ---
document.getElementById("computeBtn").addEventListener("click", async ()=>{
  const origin = document.getElementById("origin").value;
  const target = document.getElementById("target").value;
  const dep_start = document.getElementById("dep_start").value;
  const dep_end = document.getElementById("dep_end").value;
  const tof_min = parseFloat(document.getElementById("tof_min").value);
  const tof_max = parseFloat(document.getElementById("tof_max").value);
  const statusEl = document.getElementById("status");

  statusEl.textContent = "Computing best trajectory...";
  try{
    const porkchopReq = { origin, target, dep_start, dep_end, n_dep:20, tof_min, tof_max, n_tof:20 };
    const bestRes = await fetch("http://127.0.0.1:8000/best_transfer",{
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(porkchopReq)
    }).then(r=>r.json());

    const trajReq = { origin, target, dep_date:bestRes.dep_date, tof_days:bestRes.tof_days, n_samples:200 };
    const trajRes = await fetch("http://127.0.0.1:8000/trajectory",{
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(trajReq)
    }).then(r=>r.json());

    if(trajectoryLine) scene.remove(trajectoryLine);

    const points = trajRes.trajectory_km.map(p=>new THREE.Vector3(p[0]*scaleFactor,p[1]*scaleFactor,p[2]*scaleFactor));
    const geom = new THREE.BufferGeometry().setFromPoints(points);
    trajectoryLine = new THREE.Line(geom,new THREE.LineBasicMaterial({color:0xff0000, linewidth:2}));
    scene.add(trajectoryLine);

    statusEl.textContent = `Trajectory plotted! Î”v = ${bestRes.dv.toFixed(2)} km/s, TOF = ${bestRes.tof_days.toFixed(1)} days`;
  }catch(err){
    console.error(err);
    statusEl.textContent = "Error computing trajectory. Make sure backend is running.";
  }
});
</script>
</body>
</html>
